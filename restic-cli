#!/bin/bash

source "/opt/restic-cli/restic.conf"

main () {

    if [ "$1" = "update" ]; then
        update
    elif [ "$1" = "init-repo" ]; then
        init-repo
    elif [ "$1" = "init-client" ]; then
        init-client
    elif [ "$1" = "init" ]; then
        init
    elif [ "$1" = "command" ]; then
        shift
        $BIN $@
        echo "Exit code: $?"
    elif [ "$1" = "verify" ]; then
        verify
    elif ( [ "$1" = "backup" ] && [ "$#" -eq 2 ] ); then
        backup $2
    else
        about
    fi

}

init () {
    echo "###################################################"
    echo "# Welcome to restic-cli                           #"
    echo "# Wrapping Alexander Neumann's restic since 2017  #"
    echo "# Made with <3 by steilerDev                      #"
    echo "###################################################"
    echo

    # Creating restic.conf
    SCRIPT=$(realpath -s $0)
    SCRIPTPATH=$(dirname $SCRIPT)
    CONF=${SCRIPTPATH}/restic.conf

    if [ "$SCRIPTPATH" != "/opt/restic-cli" ]; then
        echo "The script path differs from the recommended directory (/opt/restic-cli). Please move the folder, or adjust the first line of this script, in order to reference the correct configuration path (it now is $SCRIPTPATH)"
    fi

    echo "Installing restic first..."
    update 

    if [ -e "$CONF" ]; then
        echo "Warning! A configuration file for restic-cli already exists ($CONF), please rename the file NOW, or it will be overwritten."
        read -p "Are you sure you want to continue? (y/n) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            > $CONF
        else
            exit
        fi
    fi

    echo "# General configurations" >> $CONF
    echo "DIR=\"${SCRIPTPATH}\"" >> $CONF
    echo "BIN_DIR=\"\${DIR}/bin" >> $CONF
    echo "BIN_NAME=\"restic\"" >> $CONF
    echo "BIN=\"\${BIN_DIR}/\${BIN_NAME}\"" >> $CONF
    echo "VERSION=\"\${BIN_DIR}/VERSION\"" >> $CONF
    echo "PID_DIR=\"/tmp\"" >> $CONF
    echo "PID_PREFIX=\"restic\"" >> $CONF
    echo "" >> $CONF

    echo "# Backend configuration" >> $CONF
    PS3='Please choose your backend for restic (see https://restic.readthedocs.io/en/stable/030_preparing_a_new_repo.html for more information): '
    options=("Local" "SFTP" "REST" "Amazon S3" "Minio Server" "OpenStack Swift" "Backblaze B2" "MS Azure Blob Storage" "Google Cloud Storage")
    select opt in "${options[@]}"   do
        case $opt in
            "Local")
                echo "Please enter your repository path (e.g.: /tmp/repo/):"
                read REPO_PATH
                echo "export RESTIC_REPOSITORY=\"${REPO_PATH}\"" >> $CONF
                ;;
            "SFTP")
                echo "Please enter your repository path (e.g.: sftp:user@host:/tmp/backup):"
                read REPO_PATH
                echo "export RESTIC_REPOSITORY=\"${REPO_PATH}\"" >> $CONF
                ;;
            "REST")
                echo "Please enter your repository path (e.g.: rest:https://host:8000/):"
                read REPO_PATH
                echo "export RESTIC_REPOSITORY=\"${REPO_PATH}\"" >> $CONF
                ;;
            "Amazon S3")
                echo "Please enter your repository path (e.g.: s3:s3.amazonaws.com/bucket_name):"
                read REPO_PATH
                echo "export RESTIC_REPOSITORY=\"${REPO_PATH}\"" >> $CONF
                echo "Please enter your access key:"
                read ACCESS_KEY
                echo "export AWS_ACCESS_KEY_ID=\"$ACCESS_KEY\"" >> $CONF
                echo "Please enter your secret access key:"
                read SECRET_ACCESS_KEY
                echo "export AWS_SECRET_ACCESS_KEY=\"$SECRET_ACCESS_KEY\"" >> $CONF
                ;;
            "Minio Server")
                echo "Please enter your repository path (e.g.: s3:http://localhost:9000/restic):"
                read REPO_PATH
                echo "export RESTIC_REPOSITORY=\"${REPO_PATH}\"" >> $CONF
                echo "Please enter your access key:"
                read ACCESS_KEY
                echo "export AWS_ACCESS_KEY_ID=\"$ACCESS_KEY\"" >> $CONF
                echo "Please enter your secret access key:"
                read SECRET_ACCESS_KEY
                echo "export AWS_SECRET_ACCESS_KEY=\"$SECRET_ACCESS_KEY\"" >> $CONF
                ;;
            "OpenStack Swift")
                echo "Not implemented here yet"
                ;;
            "Backblaze B2")
                echo "Not implemented here yet"
                ;;
            "MS Azure Blob Storage")
                echo "Not implemented here yet"
                ;;
            "Google Cloud Storage")
                echo "Not implemented here yet"
                ;;
            *) echo "Invalid option!";;
        esac
    done 

    echo "" >> $CONF

    # Loading configuration
    source $CONF

    # Init repo and/or client
    init-repo

    read -p "Each client should get it's own access password to the repository, do you want to create a unique password for this client? (y/n) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        init-client
    fi

    read -p "In order to automate the backup process you need to save the access password. Do you want to store the client's access password? (y/n) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        echo "Please enter the previously defined access password for this client, in order to store it"
        read PSWD
        echo "export RESTIC_PASSWORD=\"$PSWD\"" >> $CONF
    fi
    
    
    # Configure backups
    # BACKUP_CONFIG
}

init-repo () {
    echo "Initializing repository..."
    $BIN init
    echo "...Done"
}

init-client () {
    echo "Initializing client..."
    $BIN key add
    echo "...Done"
}

update () {
    echo -n "Checking for restic updates..."
    ARCHITECTURE="linux_amd64"

    LATEST_VERSION=$(curl -s https://api.github.com/repos/restic/restic/releases | grep -E "^    \"name\":" | grep -v "rc" | grep -ohE "[0-9]\.([0-9][\.]?)+" | head -n 1)

    if [ -e $VERSION ]; then
        CURRENT_VERSION=$(cat $VERSION)
        if [ "$CURRENT_VERSION" = "$LATEST_VERSION" ]; then
            echo "current version ($CURRENT_VERSION) is already latest version ($LATEST_VERSION)"
            return
        fi
    fi

    echo -n "found new version ($LATEST_VERSION), installing..."
    RESTIC_URL="$(curl -s https://api.github.com/repos/restic/restic/releases | grep "browser_download_url" | grep "linux_amd64" | head -n 1 | cut -d '"' -f 4)"

    # Moving old installation out of the way
    if [ -e "${BIN_DIR}/${BIN_NAME}" ]; then
        mv "${BIN_DIR}/${BIN_NAME}" "${BIN_DIR}/${BIN_NAME}.old"
    fi

    # Getting latest version
    wget $RESTIC_URL -O "${BIN_DIR}/${BIN_NAME}.bz2" > /dev/null 2>&1
    bzip2 -cd "${BIN_DIR}/${BIN_NAME}.bz2" > "${BIN_DIR}/${BIN_NAME}"
    rm "${BIN_DIR}/${BIN_NAME}.bz2"
    echo "$LATEST_VERSION" > $VERSION
    chmod +x "${BIN_DIR}/${BIN_NAME}"
    echo "Done"
}

about () {
    echo "No argument specified"
}

# Choses the right backup config and starts it
# $1: name of backup 
backup () {

    ############################################################################
    # Read config
    ############################################################################

    # Load the correct configuration
    while read -r name path excludes ; do
        if [[ $name == \#* ]] ; then
            # Ignore lines with pound
            continue
        elif [ $1 = $name ] ; then
            # If this is the choosen backup, start backup
            break
        else
            # Clear name, in case it did not match
            name=""
        fi
    done < "${BACKUP_CONFIG}"
    
    # If no config was found, exit
    if [ -z "$name" ] ; then
        echo "No backup config with name $1 found!"
        echo
        help
    fi
    
    ############################################################################
    # Check if job is already running 
    ############################################################################

    # Build PID file path for this job
    THIS_PID="${PID_DIR}/${PID_PREFIX}.${name}.pid"

    if [ -e ${THIS_PID} ] ; then
        if ps -p $(cat $THIS_PID) > /dev/null ; then
            ## If restic is currently performing a backup you can't start another one
            echo "Restic is already running"
            exit
        else
            ## If there is a PID file, but no running process delete the pid file
            rm $THIS_PID
        fi
    fi

    ############################################################################
    # Build duplicati base command 
    ############################################################################


    # 5) Set log settings
#    THIS_LOG_PATH="${LOG_PATH}${LOG_PREFIX}.${name}.log"
#    THIS_CLI_LOG_PATH="${LOG_PATH}${LOG_PREFIX}.${name}.cli.log"
#    savelog -q "${LOG_PATH}${LOG_PREFIX}.${name}.log"
#    savelog -q "${LOG_PATH}${LOG_PREFIX}.${name}.cli.log"
#    DUPLICATI_CMD+=" --log-file=\"${THIS_LOG_PATH}\"" 

    ############################################################################
    # Build duplicati options based on duplicati.conf and backup.conf 
    ############################################################################

    # This variable will hold the final options added to the call
    EXCLUDE_OPTIONS=""

    # 1) LOCAL_OPTIONS (read from backup.conf) need to be scanned, correct options need to be included, exclude paths need to be surounded by --exclude="". Everything will be put into FINAL_OPTIONS
    for EXCLUDE in $excludes ; do
        echo $EXCLUDE
        EXCLUDE_OPTIONS+="--exclude=$EXCLUDE "
    done

    
    # For debugging purposes
    echo "Invoking restic: '${BIN} ${EXCLUDE_OPTIONS} & echo \$! > ${THIS_PID}'"

    # Running command
    ${BIN} ${EXCLUDE_OPTIONS} & echo $! > ${THIS_PID}
    
    ############################################################################
    # Make duplicati quiet/monitor log files
    ############################################################################
    
    # Workaround using gdb and swapping file descriptors
    # 1) Duplicati's "--quiet-console" does not work at the moment (see https://github.com/duplicati/duplicati/issues/1752 for status)
    # 2) Adding ">>" through shell scripts results into duplicati interpreting some parts wrong and complaining about non-existing source folders
    # Currently NOT working (theoretically should work at some point and is much cleaner, therefore I will keep it here):
    # if [ "$3" = "quiet" ] ; then
    #     DUPLICATI_ARG="${DUPLICATI_ARG} --quiet-console=true >> ${THIS_CLI_LOG_PATH} 2>&1"
    # fi
    #
    # This is a workaround function, using gdb to move the file descriptor currently pointing at stdout (or similar) to the log file
    #fdswap $(cat ${THIS_DUPLICATI_PID}) ${THIS_CLI_LOG_PATH}

    # This function will detach and monitor the changes made to the CLI log in order to give a rich status summary (eg. used by duplicati status, duplicatirc)
    # In case the quiet flag is NOT set, this function will provide the output of the log file to the console
    #monitor_log ${THIS_CLI_LOG_PATH} $(cat ${THIS_DUPLICATI_PID}) ${name} $3 &
    
    ############################################################################
    # Wait for duplicati to finish, then clean and exit
    ############################################################################
    wait $(cat ${THIS_PID}) > /dev/null 2>&1
    success=$?
    rm ${THIS_PID}
    echo "Exit code was $success"
}

verify () {
    echo "Verifying repository..."
    $BIN check
    echo "Done, exit code was $?"
}

main $@
